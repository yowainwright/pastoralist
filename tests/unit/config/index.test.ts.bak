import { test, expect } from "bun:test";
import fs from "fs";
import path from "path";
import {
  validateConfig,
  safeValidateConfig,
  PastoralistConfig,
  SecurityProvider,
  SeverityThreshold,
} from "../../../src/config/constants";
import { loadConfig, loadExternalConfig, mergeConfigs } from "../../../src/config";
import { updatePackageJSON, updateAppendix } from "../../../src";
import { PastoralistJSON, Appendix } from "../../../src/types";

test("should validate minimal valid config", () => {
    const config = {};
    const result = validateConfig(config);
    expect(result).toEqual({});
  });

  it("should validate complete config with all optional properties", () => {
    const config: PastoralistConfig = {
      appendix: {
        "lodash@4.17.21": {
          rootDeps: ["app"],
          dependents: { "app": "lodash@^4.17.0" },
          patches: ["patches/lodash+4.17.21.patch"],
          ledger: {
            addedDate: "2023-01-01T00:00:00.000Z",
            reason: "Security fix",
            securityChecked: true,
            securityCheckDate: "2023-01-01T00:00:00.000Z",
            securityProvider: "osv"
          }
        }
      },
      depPaths: ["packages/*/package.json"],
      checkSecurity: true,
      overridePaths: {
        "workspace-a": {
          "axios@1.0.0": {
            dependents: { "workspace-a": "axios@^0.27.0" }
          }
        }
      },
      resolutionPaths: {
        "workspace-b": {
          "react@18.2.0": {
            dependents: { "workspace-b": "react@^18.0.0" }
          }
        }
      },
      security: {
        enabled: true,
        provider: "github",
        autoFix: false,
        interactive: true,
        securityProviderToken: "token",
        severityThreshold: "high",
        excludePackages: ["dev-package"],
        hasWorkspaceSecurityChecks: true
      }
    };

    const result = validateConfig(config);
    expect(result).toEqual(config);
  });

  it("should validate config with nested security settings", () => {
    const config = {
      security: {
        enabled: true,
        provider: "snyk" as SecurityProvider,
        severityThreshold: "critical" as SeverityThreshold,
        excludePackages: ["test-package"]
      }
    };

    const result = validateConfig(config);
    expect(result.security).toEqual(config.security);
  });

  it("should validate config with different depPaths formats", () => {
    const workspaceConfig = { depPaths: "workspace" };
    const workspacesConfig = { depPaths: "workspaces" };
    const arrayConfig = { depPaths: ["apps/*/package.json", "packages/*/package.json"] };

    expect(validateConfig(workspaceConfig).depPaths).toBe("workspace");
    expect(validateConfig(workspacesConfig).depPaths).toBe("workspaces");
    expect(validateConfig(arrayConfig).depPaths).toEqual(arrayConfig.depPaths);
  });

  it("should throw on invalid security provider enum", () => {
    const config = {
      security: {
        provider: "invalid-provider"
      }
    };

    expect(() => validateConfig(config)).toThrow();
  });

  it("should throw on invalid severity threshold", () => {
    const config = {
      security: {
        severityThreshold: "invalid-threshold"
      }
    };

    expect(() => validateConfig(config)).toThrow();
  });

  it("should throw on malformed appendix structure", () => {
    const config = {
      appendix: {
        "invalid-key": {
          ledger: {
            addedDate: "not-a-date",
            securityProvider: "invalid-provider"
          }
        }
      }
    };

    expect(() => validateConfig(config)).toThrow();
  });

  it("should return undefined for invalid config with safeValidateConfig", () => {
    const config = {
      security: {
        provider: "invalid-provider"
      }
    };

    const result = safeValidateConfig(config);
    expect(result).toBeUndefined();
  });

  it("should return parsed config for valid input with safeValidateConfig", () => {
    const config = {
      security: {
        enabled: true,
        provider: "npm"
      }
    };

    const result = safeValidateConfig(config);
    expect(result).toEqual(config);
  });
});

describe("Config Loading", () => {

  it("should load JSON config files", async () => {
    const tempDirJson = "/tmp/pastoralist-test-config-json";
    if (!fs.existsSync(tempDirJson)) {
      fs.mkdirSync(tempDirJson, { recursive: true });
    }
    const configPath = path.join(tempDirJson, ".pastoralistrc.json");
    const config = { security: { enabled: true } };
    fs.writeFileSync(configPath, JSON.stringify(config));

    const result = await loadExternalConfig(tempDirJson);
    expect(result).toEqual(config);

    if (fs.existsSync(tempDirJson)) {
      fs.rmSync(tempDirJson, { recursive: true, force: true });
    }
  });

  it("should load JS config files with default export", async () => {
    const tempDirJs = "/tmp/pastoralist-test-config-js";
    if (!fs.existsSync(tempDirJs)) {
      fs.mkdirSync(tempDirJs, { recursive: true });
    }
    const configPath = path.join(tempDirJs, "pastoralist.config.js");
    const config = { security: { provider: "github" } };
    fs.writeFileSync(configPath, `module.exports = ${JSON.stringify(config)};`);

    const result = await loadExternalConfig(tempDirJs);
    expect(result).toEqual(config);

    if (fs.existsSync(tempDirJs)) {
      fs.rmSync(tempDirJs, { recursive: true, force: true });
    }
  });

  it("should handle missing config files gracefully", async () => {
    const result = await loadExternalConfig("/nonexistent/directory");
    expect(result).toBeUndefined();
  });

  it("should handle malformed JSON files", async () => {
    const tempDirMalformed = "/tmp/pastoralist-test-config-malformed";
    if (!fs.existsSync(tempDirMalformed)) {
      fs.mkdirSync(tempDirMalformed, { recursive: true });
    }
    const configPath = path.join(tempDirMalformed, ".pastoralistrc.json");
    fs.writeFileSync(configPath, "{ invalid json }");

    const result = await loadExternalConfig(tempDirMalformed);
    expect(result).toBeUndefined();

    if (fs.existsSync(tempDirMalformed)) {
      fs.rmSync(tempDirMalformed, { recursive: true, force: true });
    }
  });

  it("should respect CONFIG_FILES precedence order", async () => {
    const tempDirPrec = "/tmp/pastoralist-test-config-precedence";
    if (!fs.existsSync(tempDirPrec)) {
      fs.mkdirSync(tempDirPrec, { recursive: true });
    }
    const rcConfig = { security: { provider: "osv" } };
    const jsonConfig = { security: { provider: "github" } };

    fs.writeFileSync(path.join(tempDirPrec, ".pastoralistrc"), JSON.stringify(rcConfig));
    fs.writeFileSync(path.join(tempDirPrec, ".pastoralistrc.json"), JSON.stringify(jsonConfig));

    const result = await loadExternalConfig(tempDirPrec);
    expect(result).toEqual(rcConfig);
    
    if (fs.existsSync(tempDirPrec)) {
      fs.rmSync(tempDirPrec, { recursive: true, force: true });
    }
  });

  it("should merge external and package.json configs", async () => {
    const tempDirMerge = "/tmp/pastoralist-test-config-merge";
    if (!fs.existsSync(tempDirMerge)) {
      fs.mkdirSync(tempDirMerge, { recursive: true });
    }
    const configPath = path.join(tempDirMerge, ".pastoralistrc.json");
    const externalConfig = { security: { enabled: true } };
    const packageJsonConfig = { depPaths: ["packages/*/package.json"] };
    
    fs.writeFileSync(configPath, JSON.stringify(externalConfig));

    const result = await loadConfig(tempDirMerge, packageJsonConfig);
    expect(result).toEqual({
      ...externalConfig,
      ...packageJsonConfig,
      appendix: undefined,
      overridePaths: {},
      resolutionPaths: {},
      security: externalConfig.security
    });
    
    if (fs.existsSync(tempDirMerge)) {
      fs.rmSync(tempDirMerge, { recursive: true, force: true });
    }
  });
});

describe("Config Merging", () => {
  it("should merge external and package.json configs", () => {
    const external = { security: { enabled: true } };
    const packageJson = { depPaths: ["apps/*/package.json"] };

    const result = mergeConfigs(external, packageJson);

    expect(result).toEqual({
      security: { enabled: true },
      depPaths: ["apps/*/package.json"],
      appendix: undefined,
      overridePaths: {},
      resolutionPaths: {}
    });
  });

  it("should handle undefined external config", () => {
    const packageJson = { depPaths: ["packages/*/package.json"] };
    const result = mergeConfigs(undefined, packageJson);
    expect(result).toEqual(packageJson);
  });

  it("should handle undefined package.json config", () => {
    const external = { security: { provider: "npm" } };
    const result = mergeConfigs(external, undefined);
    expect(result).toEqual(external);
  });

  it("should deep merge appendix objects", () => {
    const external = {
      appendix: {
        "lodash@4.17.21": {
          dependents: { "app-a": "lodash@^4.17.0" }
        }
      }
    };
    const packageJson = {
      appendix: {
        "axios@1.0.0": {
          dependents: { "app-b": "axios@^0.27.0" }
        }
      }
    };

    const result = mergeConfigs(external, packageJson);

    expect(result?.appendix?.["lodash@4.17.21"]).toBeTruthy();
    expect(result?.appendix?.["axios@1.0.0"]).toBeTruthy();
    expect(
      result?.appendix?.["lodash@4.17.21"]?.dependents
    ).toEqual({ "app-a": "lodash@^4.17.0" });
  });

  it("should deep merge security configurations", () => {
    const external = {
      security: {
        enabled: true,
        provider: "github" as SecurityProvider
      }
    };
    const packageJson = {
      security: {
        autoFix: true,
        severityThreshold: "high" as SeverityThreshold
      }
    };

    const result = mergeConfigs(external, packageJson);

    expect(result?.security).toEqual({
      enabled: true,
      provider: "github",
      autoFix: true,
      severityThreshold: "high"
    });
  });

  it("should deep merge overridePaths", () => {
    const external = {
      overridePaths: {
        "workspace-a": {
          "lodash@4.17.21": {
            dependents: { "workspace-a": "lodash@^4.17.0" }
          }
        }
      }
    };
    const packageJson = {
      overridePaths: {
        "workspace-b": {
          "axios@1.0.0": {
            dependents: { "workspace-b": "axios@^0.27.0" }
          }
        }
      }
    };

    const result = mergeConfigs(external, packageJson);

    expect(result?.overridePaths?.["workspace-a"]).toBeTruthy();
    expect(result?.overridePaths?.["workspace-b"]).toBeTruthy();
  });

  it("should prioritize package.json over external config for conflicting values", () => {
    const external = { checkSecurity: false };
    const packageJson = { checkSecurity: true };

    const result = mergeConfigs(external, packageJson);
    expect(result?.checkSecurity).toBe(true);
  });
});

describe("Package.json Preservation", () => {
  it("should preserve overridePaths when appendix is empty", async () => {
    const config: PastoralistJSON = {
      name: "test",
      version: "1.0.0",
      pastoralist: {
        overridePaths: {
          "workspace-a": {
            "lodash@4.17.21": {
              dependents: { "workspace-a": "lodash@^4.17.0" }
            }
          }
        }
      }
    };

    const result = await updatePackageJSON({
      appendix: {},
      path: "package.json",
      config,
      overrides: {},
      isTesting: true
    });

    expect(result?.pastoralist?.overridePaths).toBeTruthy();
    expect(
      result?.pastoralist?.overridePaths
    ).toEqual(config.pastoralist?.overridePaths);
  });

  it("should preserve security config when appendix is empty", async () => {
    const config: PastoralistJSON = {
      name: "test",
      version: "1.0.0",
      pastoralist: {
        security: {
          enabled: true,
          provider: "github",
          severityThreshold: "high"
        }
      }
    };

    const result = await updatePackageJSON({
      appendix: {},
      path: "package.json",
      config,
      overrides: {},
      isTesting: true
    });

    expect(result?.pastoralist?.security).toBeTruthy();
    expect(
      result?.pastoralist?.security
    ).toEqual(config.pastoralist?.security);
  });

  it("should preserve depPaths when appendix is empty", async () => {
    const config: PastoralistJSON = {
      name: "test",
      version: "1.0.0",
      pastoralist: {
        depPaths: ["packages/*/package.json", "apps/*/package.json"]
      }
    };

    const result = await updatePackageJSON({
      appendix: {},
      path: "package.json",
      config,
      overrides: {},
      isTesting: true
    });

    expect(result?.pastoralist?.depPaths).toBeTruthy();
    expect(
      result?.pastoralist?.depPaths
    ).toEqual(config.pastoralist?.depPaths);
  });

  it("should preserve resolutionPaths when appendix is empty", async () => {
    const config: PastoralistJSON = {
      name: "test",
      version: "1.0.0",
      pastoralist: {
        resolutionPaths: {
          "workspace-legacy": {
            "old-package@1.0.0": {
              dependents: { "workspace-legacy": "old-package@^0.9.0" }
            }
          }
        }
      }
    };

    const result = await updatePackageJSON({
      appendix: {},
      path: "package.json",
      config,
      overrides: {},
      isTesting: true
    });

    expect(result?.pastoralist?.resolutionPaths).toBeTruthy();
    expect(
      result?.pastoralist?.resolutionPaths
    ).toEqual(config.pastoralist?.resolutionPaths);
  });

  it("should remove pastoralist section when no configs exist", async () => {
    const config: PastoralistJSON = {
      name: "test",
      version: "1.0.0",
      pastoralist: {
        appendix: {}
      }
    };

    const result = await updatePackageJSON({
      appendix: {},
      path: "package.json",
      config,
      overrides: {},
      isTesting: true
    });

    expect(result?.pastoralist).toBeUndefined();
  });

  it("should handle mixed preservation scenarios", async () => {
    const config: PastoralistJSON = {
      name: "test",
      version: "1.0.0",
      pastoralist: {
        appendix: {},
        security: {
          enabled: true,
          provider: "osv"
        },
        depPaths: ["packages/*/package.json"]
      }
    };

    const appendix = {
      "lodash@4.17.21": {
        dependents: { "test": "lodash@^4.17.0" },
        ledger: {
          addedDate: new Date().toISOString()
        }
      }
    };

    const result = await updatePackageJSON({
      appendix,
      path: "package.json",
      config,
      overrides: { lodash: "4.17.21" },
      isTesting: true
    });

    expect(result?.pastoralist?.appendix).toEqual(appendix);
    expect(
      result?.pastoralist?.security
    ).toEqual(config.pastoralist?.security);
    expect(
      result?.pastoralist?.depPaths
    ).toEqual(config.pastoralist?.depPaths);
  });
});

describe("Security Integration", () => {
  it("should create security ledger entries with provider", () => {
    const securityOverrideDetails = [
      { packageName: "lodash", reason: "CVE-2021-23337: Command injection vulnerability" }
    ];

    const result = updateAppendix({
      overrides: { lodash: "4.17.21" },
      appendix: {},
      dependencies: { lodash: "^4.17.0" },
      packageName: "test-app",
      securityOverrideDetails,
      securityProvider: "github"
    });

    const ledger = result["lodash@4.17.21"]?.ledger;
    expect(ledger).toBeTruthy();
    expect(ledger.securityChecked).toBe(true);
    expect(ledger.securityCheckDate).toBeTruthy();
    expect(ledger.securityProvider).toBe("github");
    expect(ledger.reason).toBe("CVE-2021-23337: Command injection vulnerability");
  });

  it("should add securityChecked and securityCheckDate", () => {
    const securityOverrideDetails = [
      { packageName: "axios", reason: "Security update required" }
    ];

    const result = updateAppendix({
      overrides: { axios: "1.0.0" },
      appendix: {},
      dependencies: { axios: "^0.27.0" },
      packageName: "test-app",
      securityOverrideDetails,
      securityProvider: "snyk"
    });

    const ledger = result["axios@1.0.0"]?.ledger;
    expect(ledger).toBeTruthy();
    expect(ledger.securityChecked).toBe(true);
    expect(ledger.securityCheckDate).toBeTruthy();

    const checkDate = new Date(ledger.securityCheckDate);
    expect(isNaN(checkDate.getTime())).toBe(false);
  });

  it("should include securityProvider in ledger", () => {
    const securityOverrideDetails = [
      { packageName: "react", reason: "Security patch" }
    ];

    const providers: Array<"osv" | "github" | "snyk" | "npm" | "socket"> = ["osv", "github", "snyk", "npm", "socket"];
    
    providers.forEach(provider => {
      const result = updateAppendix({
        overrides: { react: "18.2.0" },
        appendix: {},
        dependencies: { react: "^18.0.0" },
        packageName: "test-app",
        securityOverrideDetails,
        securityProvider: provider
      });

      const ledger = result["react@18.2.0"]?.ledger;
      expect(ledger?.securityProvider).toBe(provider);
    });
  });

  it("should use security reasons from override details", () => {
    const securityOverrideDetails = [
      { packageName: "lodash", reason: "CVE-2021-23337: Command injection" },
      { packageName: "axios", reason: "CVE-2023-XXXX: SSRF vulnerability" }
    ];

    const result = updateAppendix({
      overrides: {
        lodash: "4.17.21",
        axios: "1.0.0"
      },
      appendix: {},
      dependencies: {
        lodash: "^4.17.0",
        axios: "^0.27.0"
      },
      packageName: "test-app",
      securityOverrideDetails
    });

    expect(
      result["lodash@4.17.21"]?.ledger?.reason
    ).toBe("CVE-2021-23337: Command injection");
    expect(
      result["axios@1.0.0"]?.ledger?.reason
    ).toBe("CVE-2023-XXXX: SSRF vulnerability");
  });

  it("should handle multiple security providers", () => {
    const overrideDetails1 = [
      { packageName: "lodash", reason: "Security fix from OSV" }
    ];
    const overrideDetails2 = [
      { packageName: "axios", reason: "Security fix from GitHub" }
    ];

    const result1 = updateAppendix({
      overrides: { lodash: "4.17.21" },
      appendix: {},
      dependencies: { lodash: "^4.17.0" },
      packageName: "test-app",
      securityOverrideDetails: overrideDetails1,
      securityProvider: "osv"
    });

    const result2 = updateAppendix({
      overrides: { axios: "1.0.0" },
      appendix: {},
      dependencies: { axios: "^0.27.0" },
      packageName: "test-app",
      securityOverrideDetails: overrideDetails2,
      securityProvider: "github"
    });

    expect(result1["lodash@4.17.21"]?.ledger?.securityProvider).toBe("osv");
    expect(result2["axios@1.0.0"]?.ledger?.securityProvider).toBe("github");
  });

  it("should combine security and manual overrides", () => {
    const securityOverrideDetails = [
      { packageName: "lodash", reason: "CVE-2021-23337" }
    ];
    const manualOverrideReasons = {
      "react": "Pinning for stability"
    };

    const result = updateAppendix({
      overrides: {
        lodash: "4.17.21",
        react: "18.2.0"
      },
      appendix: {},
      dependencies: {
        lodash: "^4.17.0",
        react: "^18.0.0"
      },
      packageName: "test-app",
      securityOverrideDetails,
      manualOverrideReasons,
      securityProvider: "github"
    });

    const lodashLedger = result["lodash@4.17.21"]?.ledger;
    const reactLedger = result["react@18.2.0"]?.ledger;

    expect(lodashLedger?.reason).toBe("CVE-2021-23337");
    expect(lodashLedger?.securityChecked).toBe(true);
    expect(lodashLedger?.securityProvider).toBe("github");

    expect(reactLedger?.reason).toBe("Pinning for stability");
    expect(reactLedger?.securityChecked).toBeUndefined();
  });

  it("should handle nested overrides with security details", () => {
    const securityOverrideDetails = [
      { packageName: "pg-types", reason: "CVE-2023-XXXX: SQL injection fix" }
    ];

    const result = updateAppendix({
      overrides: {
        pg: { "pg-types": "^4.0.1" }
      },
      appendix: {},
      dependencies: { pg: "^8.13.1" },
      packageName: "test-app",
      securityOverrideDetails,
      securityProvider: "snyk"
    });

    const ledger = result["pg-types@^4.0.1"]?.ledger;
    expect(ledger).toBeTruthy();
    expect(ledger.reason).toBe("CVE-2023-XXXX: SQL injection fix");
    expect(ledger.securityChecked).toBe(true);
    expect(ledger.securityProvider).toBe("snyk");
    expect(ledger.securityCheckDate).toBeTruthy();
  });
});

describe("Bug Fix: Deep merge appendix dependents", () => {
  it("should preserve dependents from both external and package.json configs", () => {
    const externalConfig: PastoralistConfig = {
      appendix: {
        "lodash@4.17.21": {
          dependents: {
            "external-app": "lodash@^4.0.0",
          },
          ledger: {
            addedDate: "2024-01-01T00:00:00.000Z",
            reason: "From external config",
          },
        },
      },
    };

    const packageJsonConfig: PastoralistConfig = {
      appendix: {
        "lodash@4.17.21": {
          dependents: {
            "my-app": "lodash@^4.17.0",
          },
          ledger: {
            addedDate: "2024-06-01T00:00:00.000Z",
            reason: "From package.json",
          },
        },
      },
    };

    const merged = mergeConfigs(externalConfig, packageJsonConfig);

    expect(merged?.appendix).toBeTruthy();
    const lodashEntry = merged.appendix["lodash@4.17.21"];
    expect(lodashEntry).toBeTruthy();
    expect(lodashEntry.dependents["external-app"]).toBeTruthy();
    expect(lodashEntry.dependents["my-app"]).toBeTruthy();
    expect(Object.keys(lodashEntry.dependents).length).toBe(2);
  });

  it("should use concat for merging patches arrays", () => {
    const externalConfig: PastoralistConfig = {
      appendix: {
        "lodash@4.17.21": {
          dependents: { app: "lodash@^4.0.0" },
          patches: ["patches/lodash+4.17.21.patch"],
        },
      },
    };

    const packageJsonConfig: PastoralistConfig = {
      appendix: {
        "lodash@4.17.21": {
          dependents: { app: "lodash@^4.0.0" },
          patches: ["patches/lodash+4.17.21-fix.patch"],
        },
      },
    };

    const merged = mergeConfigs(externalConfig, packageJsonConfig);

    expect(merged?.appendix).toBeTruthy();
    const patches = merged.appendix["lodash@4.17.21"]?.patches;
    expect(patches).toBeTruthy();
    expect(patches.length).toBe(2);
    expect(patches.includes("patches/lodash+4.17.21.patch")).toBe(true);
    expect(patches.includes("patches/lodash+4.17.21-fix.patch")).toBe(true);
  });

  it("should use Object.assign for merging overridePaths", () => {
    const externalConfig: PastoralistConfig = {
      overridePaths: {
        "packages/app": {
          "lodash@4.17.21": {
            dependents: { app: "lodash@^4.0.0" },
          },
        },
      },
    };

    const packageJsonConfig: PastoralistConfig = {
      overridePaths: {
        "packages/utils": {
          "express@4.18.2": {
            dependents: { utils: "express@^4.0.0" },
          },
        },
      },
    };

    const merged = mergeConfigs(externalConfig, packageJsonConfig);

    expect(merged?.overridePaths).toBeTruthy();
    expect(merged.overridePaths["packages/app"]).toBeTruthy();
    expect(merged.overridePaths["packages/utils"]).toBeTruthy();
  });
});

describe("Bug Fix: Config loader error messages", () => {
  it("should log error message for malformed config files", async () => {
    const tempDir = "/tmp/pastoralist-test-error-logging";
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
    const configPath = path.join(tempDir, ".pastoralistrc.json");
    fs.writeFileSync(configPath, "{ invalid json }");

    const result = await loadExternalConfig(tempDir);

    expect(result).toBeUndefined();

    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true });
    }
  });
});
